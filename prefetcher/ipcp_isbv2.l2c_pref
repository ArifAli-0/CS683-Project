/*************************************************************************************************************************
Authors:
Samuel Pakalapati - samuelpakalapati@gmail.com
Biswabandan Panda - biswap@cse.iitk.ac.in
Nilay Shah - nilays@iitk.ac.in
Neelu Shivprakash kalani - neeluk@cse.iitk.ac.in
**************************************************************************************************************************/
/*************************************************************************************************************************
Source code for "Bouquet of Instruction Pointers: Instruction Pointer Classifier-based Spatial Hardware Prefetching"
appeared (to appear) in ISCA 2020: https://www.iscaconf.org/isca2020/program/. The paper is available at
https://www.cse.iitk.ac.in/users/biswap/IPCP_ISCA20.pdf. The source code can be used with the ChampSim simulator
https://github.com/ChampSim . Note that the authors have used a modified ChampSim that supports detailed virtual
memory sub-system. Performance numbers may increase/decrease marginally
based on the virtual memory-subsystem support. Also for PIPT L1-D caches, this code may demand 1 to 1.5KB additional
storage for various hardware tables.
**************************************************************************************************************************/

#include "cache.h"
#include <map>
#include <set>
#include <cassert>
#include "training_unit.h"
#include "off_chip_info.h"

#define DO_PREF

#define NUM_BLOOM_ENTRIES 4096
#define NUM_IP_TABLE_L2_ENTRIES 64
#define NUM_IP_INDEX_BITS_L2 6
#define NUM_IP_TAG_BITS_L2 9
#define S_TYPE 1    // stream
#define CS_TYPE 2   // constant stride
#define CPLX_TYPE 3 // complex stride
#define NL_TYPE 4   // next line

// #define SIG_DEBUG_PRINT_L2				    //Uncomment to enable debug prints
#ifdef SIG_DEBUG_PRINT_L2
#define SIG_DP(x) x
#else
#define SIG_DP(x)
#endif

#define DEGREE 8

unsigned int total_access;
unsigned int predictions;
unsigned int no_prediction;
unsigned int stream_end;
unsigned int no_translation;
unsigned int reuse;
uint64_t last_address;

#define BUFFER_SIZE 128

// #define RESTRICT_REGION

struct PrefetchBuffer
{
    uint64_t buffer[BUFFER_SIZE];
    bool valid[BUFFER_SIZE];
    unsigned int next_index;

    void reset()
    {
        for (unsigned int i = 0; i < BUFFER_SIZE; i++)
            valid[i] = false;
        next_index = 0;
    }
    void add(uint64_t addr)
    {
        buffer[next_index] = addr;
        valid[next_index] = true;
        next_index = (next_index + 1) % BUFFER_SIZE;
    }

    void issue(unsigned int i)
    {
        assert(valid[i]);
        valid[i] = false;
    }

    bool get(unsigned int i, uint64_t &addr)
    {
        addr = buffer[i];
        return valid[i];
    }
};

struct ISB_prefetcher_t
{
    TUCache training_unit;

    OffChipInfo oci;

    uint64_t alloc_counter;
    uint64_t last_page;

    uint64_t stream_divergence_count;
    uint64_t stream_divergence_new_stream;
    uint64_t candidate_tlb_miss;
    uint64_t candidate_diff;
    PrefetchBuffer prefetch_buffer;

    unsigned int isb_train(unsigned int str_addr_A, uint64_t phy_addr_B)
    {
        // Algorithm for training correlated pair (A,B)
        // Step 2a : If SA(A)+1 does not exist, assign B SA(A)+1
        // Step 2b : If SA(A)+1 exists, copy the stream starting at S(A)+1 and then assign B SA(A)+1

        unsigned int str_addr_B;
        bool str_addr_B_exists = oci.get_structural_address(phy_addr_B, str_addr_B);
#ifdef DEBUG
        std::cout << "-----S(A) : " << str_addr_A << std::endl;
#endif
        // If S(A) is at a stream boundary return, we don't need to worry about B because it is as good as a stream start
        if ((str_addr_A + 1) % STREAM_MAX_LENGTH == 0)
        {
            if (!str_addr_B_exists)
            {
                str_addr_B = assign_structural_addr();
                oci.update(phy_addr_B, str_addr_B);
            }
            return str_addr_B;
        }

        bool invalidated = false;
        if (str_addr_B_exists)
        {
            // if(str_addr_B == str_addr_A + 1){
            if (str_addr_B % STREAM_MAX_LENGTH == (str_addr_A + 1) % STREAM_MAX_LENGTH)
            {
#ifdef DEBUG
                std::cout << phy_addr_B << " has a structural address of " << str_addr_B << " conf++ " << std::endl;
#endif
                oci.increase_confidence(phy_addr_B);
                return str_addr_B;
            }
            else
            {
#ifdef DEBUG
                std::cout << phy_addr_B << " has a structural address of " << str_addr_B << " conf-- " << std::endl;
#endif
                bool ret = oci.lower_confidence(phy_addr_B);
                if (ret)
                    return str_addr_B;
#ifdef DEBUG
                std::cout << "Invalidate " << std::endl;
#endif
                invalidated = true;
                oci.invalidate(phy_addr_B, str_addr_B);
                str_addr_B_exists = false;
            }
        }

        assert(!str_addr_B_exists);

        // Handle stream divergence

        unsigned int i = 1;
        uint64_t phy_addr_Aplus1;
        bool phy_addr_Aplus1_exists = oci.get_physical_address(phy_addr_Aplus1, str_addr_A + 1);

        if (phy_addr_Aplus1_exists)
            stream_divergence_count++;
#define CFIX
#ifdef CFIX
        while (phy_addr_Aplus1_exists)
        {
#ifdef DEBUG
            std::cout << "-----S(A)+1 : " << phy_addr_Aplus1 << std::endl;
#endif
            i++;

            if ((str_addr_A + i) % STREAM_MAX_LENGTH == 0)
            {
                stream_divergence_new_stream++;
                str_addr_B = assign_structural_addr();
                break;
            }
            phy_addr_Aplus1_exists = oci.get_physical_address(phy_addr_Aplus1, str_addr_A + i);

            // oci.reassign_stream(str_addr_A+1, assign_structural_addr()); //TODO TBD. Should we re-assign??
        }
        if (!phy_addr_Aplus1_exists)
            str_addr_B = str_addr_A + i;

#else
        if (phy_addr_Aplus1_exists)
        {
            // Old solution: Nothing fancy, just assign a new address
            stream_divergence_count++;
            if (invalidated)
                return str_addr_B;
            else
                str_addr_B = assign_structural_addr();
        }
        else
            str_addr_B = str_addr_A + 1;

#endif

#ifdef DEBUG
        std::cout << (void *)phy_addr_B << " allotted a structural address of " << str_addr_B << std::endl;
        std::cout << "-----S(B) : " << str_addr_B << std::endl;
#endif
        oci.update(phy_addr_B, str_addr_B);

        return str_addr_B;
    }

    vector<uint64_t> isb_predict(uint64_t trigger_phy_addr, unsigned int trigger_str_addr, uint64_t ip)
    {
#ifdef DEBUG
        std::cout << "*Trigger Str addr " << trigger_str_addr << std::endl;
#endif
        uint64_t candidate_phy_addr;
        vector<uint64_t> candidates;
        candidates.clear();

#ifndef RESTRICT_REGION
        unsigned int lookahead = 1;
        unsigned int ideal = 0;
        for (unsigned int i = 0; i < STREAM_MAX_LENGTH; i++)
        {
            if (ideal >= DEGREE)
                break;
            uint64_t str_addr_candidate = trigger_str_addr + lookahead + i;
            if (str_addr_candidate % STREAM_MAX_LENGTH == 0)
            {
                stream_end++;
                break;
            }

            bool ret = oci.get_physical_address(candidate_phy_addr, str_addr_candidate);
            if (ret)
            {
                ideal++;
                candidates.push_back(candidate_phy_addr);
            }
            else
                no_translation++;
        }
#else
        unsigned int num_prefetched = 0;
        for (unsigned int i = 0; i < STREAM_MAX_LENGTH; i++)
        {
            uint64_t str_addr_candidate = ((trigger_str_addr >> STREAM_MAX_LENGTH_BITS) << STREAM_MAX_LENGTH_BITS) + i;

            if (str_addr_candidate == trigger_str_addr)
                continue;

            bool ret = oci.get_physical_address(candidate_phy_addr, str_addr_candidate);

            if (ret)
            // if(ret && ((candidate_phy_addr >> 12) == (trigger_phy_addr >> 12)) )
            {
                candidates.push_back(candidate_phy_addr);

                if (num_prefetched >= DEGREE)
                    break;
            }
        }
#endif

        return candidates;
    }

    bool access_training_unit(uint64_t key, uint64_t &last_phy_addr, unsigned int &last_str_addr, uint64_t next_addr)
    {
        // TrainingUnitEntry* curr_training_entry = training_unit.find(key)->second;
        bool pair_found = true;
        // if(curr_training_entry == NULL)
        if (training_unit.find(key) == training_unit.end())
        {
            // std::cout << "Not found " << std::hex << key << std::endl;
            // TrainingUnitEntry* new_training_entry = training_unit.select(key);
            TrainingUnitEntry *new_training_entry = new TrainingUnitEntry;
            assert(new_training_entry);
            new_training_entry->reset();
            training_unit[key] = new_training_entry;
            pair_found = false;
        }

        assert(training_unit.find(key) != training_unit.end());
        TrainingUnitEntry *curr_training_entry = training_unit.find(key)->second;
        assert(curr_training_entry != NULL);
        last_str_addr = curr_training_entry->str_addr;
        last_phy_addr = curr_training_entry->addr;
        uint64_t last_addr = curr_training_entry->addr;
        if (last_addr == next_addr)
            return false;
#ifdef DEBUG
            // off_chip_corr_matrix.update_neighbor(last_addr, next_addr);
#endif
        return pair_found;
    }

    void update_training_unit(uint64_t key, uint64_t addr, unsigned int str_addr)
    {
        // std::cout << "Updated " << std::hex << key << " to " << addr << std::dec << std::endl;
        assert(training_unit.find(key) != training_unit.end());
        TrainingUnitEntry *curr_training_entry = training_unit.find(key)->second;
        assert(curr_training_entry);
        curr_training_entry->addr = addr;
        curr_training_entry->str_addr = str_addr;
    }

public:
    ISB_prefetcher_t()
    {
        // std::cout<<"ISB constructor constructed\n";
        training_unit.clear();
        alloc_counter = 0;
        last_page = 0;

        stream_divergence_count = 0;
        stream_divergence_new_stream = 0;
        candidate_tlb_miss = 0;
        candidate_diff = 0;
        prefetch_buffer.reset();
    }

    bool get_structural_address(uint64_t addr, unsigned int &str_addr)
    {
        return oci.get_structural_address(addr, str_addr);
    }

    unsigned int assign_structural_addr()
    {
        alloc_counter += STREAM_MAX_LENGTH;
#ifdef DEBUG
        std::cout << "  ALLOC " << alloc_counter << std::endl;
#endif
        return ((unsigned int)alloc_counter);
    }
};

ISB_prefetcher_t isb;

class STAT_COLLECT
{
public:
    uint64_t useful;
    uint64_t filled;
    uint64_t misses;
    uint64_t polluted_misses;

    uint8_t bl_filled[NUM_BLOOM_ENTRIES];
    uint8_t bl_request[NUM_BLOOM_ENTRIES];

    STAT_COLLECT()
    {
        useful = 0;
        filled = 0;
        misses = 0;
        polluted_misses = 0;

        for (int i = 0; i < NUM_BLOOM_ENTRIES; i++)
        {
            bl_filled[i] = 0;
            bl_request[i] = 0;
        }
    };
};

class IP_TABLE
{
public:
    uint64_t ip_tag;    // ip tag
    uint16_t ip_valid;  // ip valid bit
    uint32_t pref_type; // prefetch class type
    int stride;         // stride or stream

    IP_TABLE()
    {
        ip_tag = 0;
        ip_valid = 0;
        pref_type = 0;
        stride = 0;
    };
};

/*      IP TABLE STORAGE OVERHEAD: 288 Bytes

        Single Entry:

        FIELD                                   STORAGE (bits)

        IP tag                                  9
        IP valid                                1
    stride		                        7       (6 bits stride + 1 sign bit)
        prefetch type				2

    Total                                   19

        Full Table Storage Overhead:

        64 entries * 19 bits = 1216 bits = 152 Bytes

*/

STAT_COLLECT stats_l2[NUM_CPUS][5]; // for GS, CS, CPLX, NL and no class
uint64_t num_misses_l2[NUM_CPUS] = {0};
// DELTA_PRED_TABLE CSPT_l2[NUM_CPUS][NUM_CSPT_L2_ENTRIES];
uint32_t spec_nl_l2[NUM_CPUS] = {0};
IP_TABLE trackers[NUM_CPUS][NUM_IP_TABLE_L2_ENTRIES];

uint64_t hash_bloom_l2(uint64_t addr)
{
    uint64_t first_half, sec_half;
    first_half = addr & 0xFFF;
    sec_half = (addr >> 12) & 0xFFF;
    if ((first_half ^ sec_half) >= 4096)
        assert(0);
    return ((first_half ^ sec_half) & 0xFFF);
}

/*decode_stride: This function decodes 7 bit stride from the metadata from IPCP at L1. 6 bits for magnitude and 1 bit for sign. */

int decode_stride(uint32_t metadata)
{
    int stride = 0;
    if (metadata & 0b1000000)
        stride = -1 * (metadata & 0b111111);
    else
        stride = metadata & 0b111111;

    return stride;
}

/* update_conf_l2: If the actual stride and predicted stride are equal, then the confidence counter is incremented. */

int update_conf_l1(int stride, int pred_stride, int conf)
{
    if (stride == pred_stride)
    { // use 2-bit saturating counter for confidence
        conf++;
        if (conf > 3)
            conf = 3;
    }
    else
    {
        conf--;
        if (conf < 0)
            conf = 0;
    }

    return conf;
}

/* encode_metadata_l2: This function encodes the stride, prefetch class type and speculative nl fields in the metadata. */

uint32_t encode_metadata_l2(int stride, uint16_t type, int spec_nl_l2)
{

    uint32_t metadata = 0;

    // first encode stride in the last 8 bits of the metadata
    if (stride > 0)
        metadata = stride;
    else
        metadata = ((-1 * stride) | 0b1000000);

    // encode the type of IP in the next 4 bits
    metadata = metadata | (type << 8);

    // encode the speculative NL bit in the next 1 bit
    metadata = metadata | (spec_nl_l2 << 12);

    return metadata;
}

void stat_col_L2(uint64_t addr, uint8_t cache_hit, uint8_t cpu, uint64_t ip)
{
    uint64_t index = hash_bloom_l2(addr);
    int ip_index = ip & ((1 << NUM_IP_INDEX_BITS_L2) - 1);
    uint16_t ip_tag = (ip >> NUM_IP_INDEX_BITS_L2) & ((1 << NUM_IP_TAG_BITS_L2) - 1);

    for (int i = 0; i < 5; i++)
    {
        if (cache_hit)
        {
            if (stats_l2[cpu][i].bl_filled[index] == 1)
            {
                stats_l2[cpu][i].useful++;
                stats_l2[cpu][i].filled++;
                stats_l2[cpu][i].bl_filled[index] = 0;
            }
        }
        else
        {
            if (ip_tag == trackers[cpu][ip_index].ip_tag)
            {
                if (trackers[cpu][ip_index].pref_type == i)
                    stats_l2[cpu][i].misses++;
                if (stats_l2[cpu][i].bl_filled[index] == 1)
                {
                    stats_l2[cpu][i].polluted_misses++;
                    stats_l2[cpu][i].filled++;
                    stats_l2[cpu][i].bl_filled[index] = 0;
                }
            }
        }

        if (num_misses_l2[cpu] % 1024 == 0)
        {
            for (int j = 0; j < NUM_BLOOM_ENTRIES; j++)
            {
                stats_l2[cpu][i].filled += stats_l2[cpu][i].bl_filled[j];
                stats_l2[cpu][i].bl_filled[j] = 0;
                stats_l2[cpu][i].bl_request[j] = 0;
            }
        }
    }
}

void CACHE::l2c_prefetcher_initialize()
{
    total_access = 0;
    predictions = 0;
    no_prediction = 0;
    stream_end = 0;
    no_translation = 0;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint8_t critical_ip_flag) // uint64_t prefetch_id),
{
    uint64_t page = addr >> LOG2_PAGE_SIZE;
    uint64_t curr_tag = (page ^ (page >> 6) ^ (page >> 12)) & ((1 << NUM_IP_TAG_BITS_L2) - 1);
    uint64_t line_offset = (addr >> LOG2_BLOCK_SIZE) & 0x3F;
    uint64_t line_addr = addr >> LOG2_BLOCK_SIZE;
    int prefetch_degree = 0;
    int64_t stride = decode_stride(metadata_in);
    uint32_t pref_type = (metadata_in & 0xF00) >> 8;
    uint16_t ip_tag = (ip >> NUM_IP_INDEX_BITS_L2) & ((1 << NUM_IP_TAG_BITS_L2) - 1);
    int num_prefs = 0;
    uint64_t bl_index = 0;
    if (NUM_CPUS == 1)
    {
        prefetch_degree = 3;
    }
    else
    { // tightening the degree for multi-core
        prefetch_degree = 2;
    }

    stat_col_L2(addr, cache_hit, cpu, ip);
    if (cache_hit == 0 && type != PREFETCH)
        num_misses_l2[cpu]++;

    // calculate the index bit
    int index = ip & ((1 << NUM_IP_INDEX_BITS_L2) - 1);
    if (trackers[cpu][index].ip_tag != ip_tag)
    { // new/conflict IP
        if (trackers[cpu][index].ip_valid == 0)
        { // if valid bit is zero, update with latest IP info
            trackers[cpu][index].ip_tag = ip_tag;
            trackers[cpu][index].pref_type = pref_type;
            trackers[cpu][index].stride = stride;
        }
        else
        {
            trackers[cpu][index].ip_valid = 0; // otherwise, reset valid bit and leave the previous IP as it is
        }

        // issue a next line prefetch upon encountering new IP
        uint64_t pf_address = ((addr >> LOG2_BLOCK_SIZE) + 1) << LOG2_BLOCK_SIZE;
        // Ensure it lies on the same 4 KB page.
        if ((pf_address >> LOG2_PAGE_SIZE) == (addr >> LOG2_PAGE_SIZE))
        {
#ifdef DO_PREF
            prefetch_line(ip, addr, pf_address, FILL_L2, 0);
#endif
            SIG_DP(cout << "1, ");
        }
        return metadata_in;
    }
    else
    { // if same IP encountered, set valid bit
        trackers[cpu][index].ip_valid = 1;
    }

    // update the IP table upon receiving metadata from prefetch
    if (type == PREFETCH)
    {
        trackers[cpu][index].pref_type = pref_type;
        trackers[cpu][index].stride = stride;
        spec_nl_l2[cpu] = metadata_in & 0x1000;
    }

    SIG_DP(
        cout << ip << ", " << cache_hit << ", " << line_addr << ", ";
        cout << ", " << stride << "; ";);

    if ((trackers[cpu][index].pref_type == 1 || trackers[cpu][index].pref_type == 2) && trackers[cpu][index].stride != 0)
    { // S or CS class
        uint32_t metadata = 0;
        if (trackers[cpu][index].pref_type == 1)
        {
            prefetch_degree = prefetch_degree * 2;
            metadata = encode_metadata_l2(1, S_TYPE, spec_nl_l2[cpu]); // for stream, prefetch with twice the usual degree
        }
        else
        {
            metadata = encode_metadata_l2(1, CS_TYPE, spec_nl_l2[cpu]); // for stream, prefetch with twice the usual degree
        }

        for (int i = 0; i < prefetch_degree; i++)
        {
            uint64_t pf_address = (line_addr + (trackers[cpu][index].stride * (i + 1))) << LOG2_BLOCK_SIZE;

            // Check if prefetch address is in same 4 KB page
            if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                break;
            num_prefs++;
#ifdef DO_PREF
            prefetch_line(ip, addr, pf_address, FILL_L2, metadata);
#endif
            SIG_DP(cout << trackers[cpu][index].stride << ", ");
        }
    }


    uint64_t addr_B = (addr >> 6) << 6;
    uint64_t key = ip;

    if (addr_B == last_address)
        return 1;
    last_address = addr_B;

    total_access++;

#ifdef DEBUG
    std::cout << "**Trigger " << std::hex << addr_B << " with key " << std::hex << key << std::endl;
#endif

    unsigned int str_addr_B = 0;
    bool str_addr_B_exists = isb.oci.get_structural_address(addr_B, str_addr_B);

    if (str_addr_B_exists)
    {
        vector<uint64_t> candidates = isb.isb_predict(addr_B, str_addr_B, ip);
        unsigned int num_prefetched = 0;
        for (unsigned int i = 0; i < candidates.size(); i++)
        {
            int ret = prefetch_line(ip, addr, candidates[i], FILL_L2, 0);
            if (ret == 1)
            {
                predictions++;
                num_prefetched++;
            }
            if (num_prefetched >= DEGREE)
                break;
        }
    }
    else
        no_prediction++;

    if (!cache_hit)
    {
        unsigned int str_addr_A;
        uint64_t addr_A;
        if (isb.access_training_unit(key, addr_A, str_addr_A, addr_B))
        {
#ifdef DEBUG
            std::cout << "Consider pair " << str_addr_A << " and " << addr_B << " with key as " << key << std::endl;
#endif
            if (str_addr_A == 0)
            { // TBD, when is this condition true? When this is the 2nd access to the pc
                str_addr_A = isb.assign_structural_addr();
                isb.oci.update(addr_A, str_addr_A);
            }
            str_addr_B = isb.isb_train(str_addr_A, addr_B);
        }

        isb.update_training_unit(key, addr_B, str_addr_B);
    }
    // if no prefetches are issued till now, speculatively issue a next_line prefetch
    if (num_prefs == 0 && spec_nl_l2[cpu] == 1)
    { // NL IP
        uint64_t pf_address = ((addr >> LOG2_BLOCK_SIZE) + 1) << LOG2_BLOCK_SIZE;
        // If it is not in the same 4 KB page, return.
        if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
        {
            return metadata_in;
        }
        bl_index = hash_bloom_l2(pf_address);
        stats_l2[cpu][NL_TYPE].bl_request[bl_index] = 1;
        uint32_t metadata = encode_metadata_l2(1, NL_TYPE, spec_nl_l2[cpu]);
        trackers[cpu][index].pref_type = 3;
#ifdef DO_PREF
        prefetch_line(ip, addr, pf_address, FILL_L2, metadata);
#endif
        SIG_DP(cout << "1, ");
    }

    SIG_DP(cout << endl);
    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{

    if (prefetch)
    {
        uint32_t pref_type = metadata_in & 0xF00;
        pref_type = pref_type >> 8;

        uint64_t index = hash_bloom_l2(addr);
        if (stats_l2[cpu][pref_type].bl_request[index] == 1)
        {
            stats_l2[cpu][pref_type].bl_filled[index] = 1;
            stats_l2[cpu][pref_type].bl_request[index] = 0;
        }
    }

    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
}